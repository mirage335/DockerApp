#!/usr/bin/env bash

# Copyright (C) 2017 mirage335

# This file is part of DockerApp.

# DockerApp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# DockerApp is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with DockerApp.  If not, see <http://www.gnu.org/licenses/>.

#####Utilities.
#Retrieves absolute path of current script, while maintaining symlinks, even when "./" would translate with "readlink -f" into something disregarding symlinked components in $PWD.
#However, will dereference symlinks IF the script location itself is a symlink. This is to allow symlinking to scripts to function normally.
#Suitable for allowing scripts to find other scripts they depend on. May look like an ugly hack, but it has proven reliable over the years.
_getScriptAbsoluteLocation() {
	local absoluteLocation
	if [[ (-e $PWD\/$0) && ($0 != "") ]]
			then
	absoluteLocation="$PWD"\/"$0"
	absoluteLocation=$(realpath -s "$absoluteLocation")
			else
	absoluteLocation="$0"
	fi

	if [[ -h "$absoluteLocation" ]]
			then
	absoluteLocation=$(readlink -f "$absoluteLocation")
	fi

	echo $absoluteLocation
}


#Suitable for allowing scripts to find other scripts they depend on.
_getScriptAbsoluteFolder() {
	dirname "$(_getScriptAbsoluteLocation)"
}

#Retrieves absolute path of parameter, while maintaining symlinks, even when "./" would translate with "readlink -f" into something disregarding symlinked components in $PWD.
#Suitable for finding absolute paths, when it is desirable not to interfere with symlink specified folder structure.
_getAbsoluteLocation() {
	local absoluteLocation
	if [[ (-e $PWD\/$1) && ($1 != "") ]]
			then
	absoluteLocation="$PWD"\/"$1"
	absoluteLocation=$(realpath -s "$absoluteLocation")
			else
	absoluteLocation="$1"
	fi
	echo $absoluteLocation
}

#Retrieves absolute path of parameter, while maintaining symlinks, even when "./" would translate with "readlink -f" into something disregarding symlinked components in $PWD.
#Suitable for finding absolute paths, when it is desirable not to interfere with symlink specified folder structure.
_getAbsoluteFolder() {
	local absoluteLocation=$(_getAbsoluteLocation "$1")
	dirname "$absoluteLocation"
}

#http://stackoverflow.com/questions/687948/timeout-a-command-in-bash-without-unnecessary-delay
_timeout() { ( set +b; sleep "$1" & "${@:2}" & wait -n; r=$?; kill -9 `jobs -p`; exit $r; ) }

_checkDep() {
	type "$1" >/dev/null 2>&1 || ( echo "$1" missing && _stop 1 )
}

#Portable sanity checked "rm -r" command.
#"$1" == directory to remove
_safeRMR() {
	
	#if [[ ! -e "$0" ]]
	#then
	#	return 1
	#fi
	
	if [[ "$1" == "" ]]
	then
		return 1
	fi
	
	if [[ "$1" == "/" ]]
	then
		return 1
	fi
	
	#Blacklist.
	[[ "$1" == "/home" ]] && return 1
	[[ "$1" == "/home/" ]] && return 1
	[[ "$1" == "/home/$USER" ]] && return 1
	[[ "$1" == "/home/$USER/" ]] && return 1
	[[ "$1" == "/$USER" ]] && return 1
	[[ "$1" == "/$USER/" ]] && return 1
	
	[[ "$1" == "/tmp" ]] && return 1
	[[ "$1" == "/tmp/" ]] && return 1
	
	#Whitelist.
	local safeToRM=false
	
	local safeScriptAbsoluteFolder="$_getScriptAbsoluteFolder"
	
	[[ "$1" == "./"* ]] && [[ "$PWD" == "$safeScriptAbsoluteFolder"* ]] && safeToRM="true"
	
	[[ "$1" == "$safeScriptAbsoluteFolder"* ]] && safeToRM="true"
	
	#[[ "$1" == "/home/$USER"* ]] && safeToRM="true"
	[[ "$1" == "/tmp/"* ]] && safeToRM="true"
	
	[[ "$safeToRM" == "false" ]] && return 1
	
	#Safeguards/
	[[ -d "$1" ]] && find "$1" | grep -i '\.git$' >/dev/null 2>&1 && return 1
	
	#Validate necessary tools were available for path building and checks.
	_checkDep realpath
	_checkDep readlink
	_checkDep dirname
	_checkDep basename
	
	if [[ -e "$1" ]]
	then
		#sleep 0
		#echo "$1"
		rm -rf "$1"
	fi
}

#Generates random alphanumeric characters, default length 18.
_uid() {
	local uidLength
	[[ -z "$1" ]] && uidLength=18 || uidLength="$1"
	
	cat /dev/urandom | base64 | tr -dc 'a-zA-Z0-9' | head -c "$uidLength"
}


#Gets filename extension.
#"$1" == filename
_getExt() {
	echo "$1" | tr -dc 'a-zA-Z0-9.' | tr '[:upper:]' '[:lower:]' | tail -c 4
}

#Validates non-empty request.
_validateRequest() {
	echo -e -n '\E[1;32;46m Validating request '"$1"'...	\E[0m'
	[[ "$1" == "" ]] && echo -e '\E[1;33;41m BLANK \E[0m' && return 1
	echo "PASS"
	return
}


#####Basic Variable Management


_deriveBaseImageContainerNames() {
	
	#Sub-object Names
	export baseObjectName=$(echo "$objectName" | cut -s -d\- -f3)
	export imageObjectName=$(echo "$objectName" | cut -s -d\- -f2)
	export containerObjectName=$(echo "$objectName" | cut -d\- -f1)
	
	if ! echo "$baseObjectName" | grep ':' >/dev/null 2>&1
	then
		baseObjectName="$baseObjectName"":latest"
	fi
	
	if ! echo "$imageObjectName" | grep ':' >/dev/null 2>&1
	then
		imageObjectName="$imageObjectName"":latest"
	fi
	
	imageObjectNameSane=$(echo "$imageObjectName" | tr ':/' '__' | tr -dc 'a-zA-Z0-9_')
	
	containerObjectName="$containerObjectName""_""$imageObjectNameSane"
	
}


#####Global variables.
export sessionid=$(_uid)
export scriptAbsoluteLocation=$(_getScriptAbsoluteLocation)
export scriptAbsoluteFolder=$(_getScriptAbsoluteFolder)

#Temporary directories.
export safeTmp="$scriptAbsoluteFolder"/w_"$sessionid"
export logTmp="$safeTmp"/log
export shortTmp=/tmp/w_"$sessionid"	#Solely for misbehaved applications called upon.

#Monolithic shared files.
export importFile="$logTmp"/import

#Resource directories.
export guidanceDir="$scriptAbsoluteFolder"/guidance

#Object Dir
export objectDir="$scriptAbsoluteFolder"

#Object Name
export objectName=$(basename "$objectDir")

#Sub-object Names
_deriveBaseImageContainerNames


#####Local Environment Management

_prepare() {
	
	mkdir -p "$safeTmp"
	
	mkdir -p "$shortTmp"
	
	mkdir -p "$logTmp"
}

_start() {
	
	_prepare
	
	
}

_stop() {
	
	_safeRMR "$safeTmp"
	_safeRMR "$shortTmp"
	
	#Broken.
	if [[ "$1" != "" ]]
	then
		exit "$1"
	else
		exit 0
	fi
}


#Traps
trap 'excode=$?; _stop; trap - EXIT; echo $excode' EXIT HUP INT QUIT PIPE TERM		# reset
trap 'excode=$?; trap "" EXIT; _stop; echo $excode' EXIT HUP INT QUIT PIPE TERM		# ignore

#####Installation functions.
_test() {
	_start
	
	echo -e -n '\E[1;32;46m Dependency checking...	\E[0m'
	
	# Check dependencies
	_checkDep wget
	_checkDep grep
	_checkDep sed
	_checkDep awk
	_checkDep cut
	_checkDep head
	_checkDep tail
	
	
	_checkDep realpath
	_checkDep readlink
	_checkDep dirname
	
	_checkDep sleep
	_checkDep wait
	_checkDep kill
	_checkDep jobs
	_checkDep exit
	
	_checkDep env
	_checkDep bash
	_checkDep echo
	_checkDep cat
	_checkDep type
	_checkDep mkdir
	_checkDep trap
	_checkDep return
	_checkDep set
	
	_checkDep rm
	
	
	[[ -e /dev/urandom ]] || echo /dev/urandom missing _stop
	
	echo "PASS"
	
	_stop
	
}

_setup() {
	_start
	
	"$scriptAbsoluteLocation" _test
	
	"$scriptAbsoluteLocation" _build "$@"
	
	
	
	_stop
}


#####Program functions.



## Docker Ops


#DANGER: Really removes all docker images/containers.
_clearAll() {
	
	docker rm $(docker ps -a -q)
	docker rmi --force $(docker images -q)
	echo y | docker system prune
	
}


_build_base_scratch() {
	
	
	echo -e -n '\E[1;32;46m Searching, base...	\E[0m'
	
	[[ "$(docker images -q "$baseObjectName" 2> /dev/null)" != "" ]] && echo -e '\E[1;33;41m EXISTS \E[0m' && return
	echo "PASS"
	
	echo -e -n '\E[1;32;46m Building '"$baseObjectName"' base...	\E[0m'
	cd "$objectDir"
	tar cv --files-from /dev/null | docker import - "$baseObjectName" 2> /dev/null > "$logTmp"/buildBase
	cd "$scriptAbsoluteFolder"
	
	[[ "$(docker images -q "$baseObjectName" 2> /dev/null)" == "" ]]  && echo -e '\E[1;33;41m FAIL \E[0m' && return 1
	echo "PASS"
	
}


_build_base() {
	echo -e -n '\E[1;32;46m Validating request '"$baseObjectName"'...	\E[0m'
	
	[[ "$baseObjectName" == "" ]] && echo -e '\E[1;33;41m BLANK \E[0m' && return 1
	
	[[ "$baseObjectName" == "scratch:latest" ]] && echo "PASS" && _build_base_scratch && return
	
	
	#No local build instructons found, will rely on upstream provider.
	echo -e '\E[1;33;41m WARN \E[0m'
	return 1
	
	
	
}

_build_image() {
	_validateRequest "$imageObjectName" || return 1
	
	
	echo -e -n '\E[1;32;46m Searching, image...	\E[0m'
	
	[[ "$(docker images -q "$imageObjectName" 2> /dev/null)" != "" ]] && echo -e '\E[1;33;41m EXISTS \E[0m' && return
	echo "PASS"
	
	echo -e -n '\E[1;32;46m Building '"$imageObjectName"' image...	\E[0m'
	cd "$objectDir"
	docker build --rm --tag "$imageObjectName" . 2> /dev/null > "$logTmp"/buildImage
	cd "$scriptAbsoluteFolder"
	
	[[ "$(docker images -q "$imageObjectName" 2> /dev/null)" == "" ]]  && echo -e '\E[1;33;41m FAIL \E[0m' && return 1
	echo "PASS"
	
	
}

_build_container() {
	_validateRequest "$containerObjectName" || return 1
	
	echo -e -n '\E[1;32;46m Searching, containers...	\E[0m'
	
	local dockerContainerID
	dockerContainerID=$(docker ps -a -q --filter name='^/'"$containerObjectName"'$')
	[[ "$dockerContainerID" != "" ]] && echo -e '\E[1;33;41m EXISTS \E[0m' && return
	echo "PASS"
	
	echo -e -n '\E[1;32;46m Building '"$containerObjectName"' container...	\E[0m'
	cd "$objectDir"
	docker create -t -i --name "$containerObjectName" "$imageObjectName" 2> /dev/null > "$logTmp"/buildContainer
	cd "$scriptAbsoluteFolder"
	
	dockerContainerID=$(docker ps -a -q --filter name='^/'"$containerObjectName"'$')
	[[ "$dockerContainerID" == "" ]]  && echo -e '\E[1;33;41m FAIL \E[0m' && return 1
	echo "PASS"
	
	
}

_build() {
	_start
	
	_collect "$@" 
	
	
	
	_build_base
	_build_image
	_build_container
	
	#_preserveLog
	
	_stop
}



## CORE
_preserveLog() {
	cp "$logTmp"/* ./  >/dev/null 2>&1
}


# DO NOT OVERRIDE, MAY CALL OPS
#Specialized global variables, directories, subscripts. Equivalent to prepare(). 
_collect() {
	
	
	[[ -e "$scriptAbsoluteFolder"/dockerfile ]] && return
	
	if [[ -e "$1"/dockerfile ]] && [[ -d "$1" ]]
	then
		
		#Object Dir
		export objectDir=$(_getAbsoluteLocation "$1")

		#Object Name
		export objectName=$(basename "$objectDir")

		_deriveBaseImageContainerNames
		
		#Override functions and variables with external definitions from a separate file if available.
		if [[ -e "$1"/ops ]]
		then 
			. "$1"/ops
		fi
		
		
		return
	fi
	
	echo -e '\E[1;33;41m DOCKERFILE NOT FOUND \E[0m'
	echo -e '\E[1;33;41m cd /directory/with/dockerfile ; ./launch \E[0m'
	echo -e '\E[1;33;41m ./launch /directory/with/dockerfile \E[0m'
	
	
	
	
	
	
	
	
	
	
	
	
	_stop
	
}

_commit() {
	
	docker commit "$containerObjectName" "$imageObjectName"
	
}

_launch() {
	
	docker start -ia "$containerObjectName"
	
}

_attach() {
	
	docker attach "$containerObjectName"
	
}

_on() {
	_start
	
	docker start "$containerObjectName" > "$logTmp"/log_on
	
	#_preserveLog
	
	_stop
	
}

_off() {
	_start
	
	docker stop -t 10 "$containerObjectName" > "$logTmp"/log_off
	
	#_preserveLog
	
	_stop
	
}

#Program entry point.
#"$1" == recipeCfg
_main() {
	
	_start
	
	_collect "$@" 
	
	
	"$scriptAbsoluteLocation" _setup "$@" > "$logTmp"/setup
	
	_start
	
	_launch
	
	#_preserveLog
	
	_stop
	
	
}

#Override functions with external definitions from a separate file if available.
if [[ -e "./ops" ]]
then
	. ./ops
fi

#Override functions with external definitions from a separate file if available.
if [[ -e "$guidanceDir"/ops ]]
then
	. "$guidanceDir"/ops
fi


#Launch internal functions as commands.
#if [[ "$1" != "" ]] && [[ "$1" != "-"* ]] && [[ ! -e "$1" ]]
if [[ "$1" == '_'* ]]
then
	"$@"
	exit "$?"
	#_stop "$?"
fi

#Stop if script is imported into an existing shell.
if [[ "${BASH_SOURCE[0]}" != "${0}" ]] && [[ "$1" != "--bypass" ]]
then
	return
fi

if ! [[ "$1" != "--bypass" ]]
then
	shift
fi


#"$scriptAbsoluteLocation" _setup


_main "$@"















































